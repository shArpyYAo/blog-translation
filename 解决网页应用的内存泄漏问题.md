# 解决网页应用的内存泄漏问题


##### By [Nolan Lawson](https://nolanlawson.com/about/) | Feb 19, 2020

[原文](https://nolanlawson.com/2020/02/19/fixing-memory-leaks-in-web-applications/)

从以前服务端渲染切换到现在客户端渲染的单页面应用时，我们不得不妥协的东西是，我们突然不得不更加注意用户设备上的资源。不要阻塞UI线程，不要提高笔记本电脑的风扇转速，不要耗尽手机电池的电量，等等。我们为了提供更好的交互体验和类似手机app的体验，换取了以上在服务端渲染时不会出现的问题。

其中一个问题就是内存泄漏。编码糟糕的单页面应用可能很容易耗尽上MB甚至上GB的内存。从而继续吞噬越来越多的资源，即使只在后台默默运行着。此时，页面开始卡顿，或者浏览器直接关掉了这个糟糕的tab并且你会看到Chrome熟悉的“Aw, snap!”页面。

![](https://nolanwlawson.files.wordpress.com/2020/02/awsnap.png)

（当然，服务端渲染的网站也可能会泄漏服务端的内存。但是，极不可能泄漏客户端的内存，因为每次你在页面之间导航时，浏览器都会清除内存）

Web开发文献中没有很好地解决内存泄漏的问题。但是，我非常确定大多数重要的单页面应用网站都会泄漏内存，除非它们背后的团队拥有强大的架构设计来捕获和修复内存泄漏。用JavaScript太容易了，以至于不小心分配了一些内存而忘了清理它。

那么，为什么这么少写关于内存泄漏的文章呢？ 我的猜测：
* 用户抱怨很少：大多数用户在上网时都不会看任务管理器。通常，除非泄漏严重到导致选项卡崩溃或应用程序运行缓慢，否则你是不会从用户那里听到有关它的消息。
* 缺乏数据：Chrome团队不会提供有关网站使用多少内存的数据。网站开发者自己也不是经常测量的。
* 缺乏工具：缺乏工具识别或修复内存泄漏。
* 没有过多关注：浏览器非常擅长杀死消耗过多内存的标签页。另外，人们似乎将责任归咎于浏览器而非网站。

在这篇文章中，我想分享一些我在解决Web应用程序中的内存泄漏方面的经验，并提供一些示例来说明如何有效地跟踪它们。

## 解剖内存泄漏

像React、Vue和Svelte这样的现代Web应用程序框架都使用基于组件的模型。 在此模型中，引入内存泄漏的最常见方法是这样的：

        window.addEventListener('message', this.onMessage.bind(this));

就是这样，这样就内存泄漏了。如果你在组件里面使用全局的对象上调用addEventListener，然后卸载组件（译者注：组件被销毁时）时忘记使用removeEventListener对其进行清理，这样就会内存泄露。

更糟的是，你泄露了整个组件。因为this.onMessage绑定了this，组件内容已经被泄露了。因此，会具有其所有子组件（译者注：如果有子组件的话）。而且很可能所有与组件相关联的DOM节点也是如此。这会很快变得非常糟糕。

修复它：

        // Mount phase
        this.onMessage = this.onMessage.bind(this);
        window.addEventListener('message', this.onMessage);
        
        // Unmount phase
        window.removeEventListener('message', this.onMessage);

注意我们给onMessage函数存了一份引用。你必须保证addEventListener的函数与removeEventListener的函数完全相同，否则它将无法正常工作。

## 内存泄漏情况

以我的经验，如下所示的API最容易出现内存泄漏的情况：

* addEventListener：这是最常见的一种，调用removeEventListener清除
* setTimeout / setInterval：如果你创建一个定期计时器（例如每30秒运行一次），则需要使用clearTimeout或clearInterval对其进行清理。（如果使用setTimeout模拟setInterval，即在setTimeout回调中安排新的setTimeout，则setTimeout可能会泄漏（译者注：每次回调都创建新的定时器，旧的没有删除）） 
* IntersectionObserver、ResizeObserver、MutationObserver，等等：这些新颖的API非常方便，但也很可能会泄漏。如果你在组件内部创建一个组件，并将其附加到全局可用元素，则需要调用disconnect进行清理。（请注意，被垃圾收集的DOM节点也会对它们的侦听器和观察者进行垃圾收集。因此，通常，你只需要担心全局元素，例如body元素、文档、无所不在的页眉/页脚元素，等等。）
* Promises, Observables, EventEmitters，等等：如果你忘记停止监听，则任何用于设置监听的编程模型（译者注：发布订阅之类的）都可能会泄漏内存。（如果Promise从未得到resolved或rejected，则可能会泄漏，在这种情况下，附加到它的任何then回调都将泄漏。）
* 全局对象存储。像Redux的state是全局的，因此，如果你一个不小心，你就会只往内存添加东西而不会清除它。
* 无限制的dom增长。如果你不用虚拟列表（译者注：就是dom固定只有几个元素，然后动态添加删除dom元素）来实现无限滚动列表，则DOM节点的数量将无限增加。
	
当然，还有许多其他方法可以泄漏内存，但这是我见过的最常见的方法。

## 识别内存泄漏

这是困难的部分。我首先要说的是，我只是认为浏览器自带的工具都不是很好。我尝试使用Firefox的内存工具，Edge和IE内存工具，甚至Windows Performance Analyzer。但同类最佳的是Chrome的内存工具，但是它也有很多粗糙的部分。

在Chrome DevTools中，我们选择的主要工具将是“Memory”标签中的“heap snapshot”工具。Chrome中还有其他监听内存的工具，但我发现它们对识别泄漏没有太大帮助。

![](https://nolanwlawson.files.wordpress.com/2020/02/screenshot-from-2020-02-16-11-03-49.png)

当你点击“take snapshot”按钮时，你已经捕获了该网页上特定JavaScript实例中的所有活动对象。这包括window引用的对象，由setInterval回调引用的对象等。这些就是代表该网页使用的所有内存的某一瞬间（译者注：某一瞬间在下文统一为快照）。

下一步是重现你认为可能泄漏的某些场景，例如，打开和关闭模态框。模态框关闭后，理想状态下内存会恢复到打开前的水平。因此，你需要分别拍摄打开前、打开后、关闭后的快照来对比。这个功能确实是该工具牛逼的地方。

![](https://nolanwlawson.files.wordpress.com/2020/02/leak-scenario.png?w=570&h=285)

然而，你应该注意该工具有一些限制：
* 即使单击“collect garbage”小按钮，你可能也需要为Chrome连续拍摄几个快照才能真正清除未引用的内存。以我的经验，三个就足够了。（检查每个快照的总内存大小直到它最终应稳定下来。）
* 如果你有web workers，service workers，iframe，shared workers等，这些内存将不会在快照中显示，因为它位于另一个JavaScript实例中。你想要捕获这些内存也是可以的，但需要哪一个是你要的。
* 有时候快照会卡住动不了，这时候只能重新关掉tab页再打开了
	
此时，如果你的应用不复杂，那么你可能会在两个快照之间看到很多泄漏的对象。这是棘手的地方，因为并非所有这些都是真正的泄漏。其中许多只是正常使用，比如说某些对象被取消分配而有利于另一个对象，某些对象以某种方式被缓存，以便稍后进行清理，等等。

## 消除噪音

我发现消除噪音的最佳方法是重复几次泄漏内存的操作。例如，你不仅可以打开和关闭模式对话框一次，还可以将其重复7次。（7是一个明显的质数）然后，你可以检查快照差异以查看是否有任何对象泄漏7次。（或14次或21次。）

![](https://nolanwlawson.files.wordpress.com/2020/02/screenshot-from-2020-02-16-10-56-12-2.png)
图片说明：快照差异。请注意，我们将6号快照与3号快照进行比较，因为我连续拍摄了三个快照以进行更多垃圾回收。另请注意，有几个对象泄漏了7次。

（另一种有用的技术是在记录第一个快照之前先操作一次泄漏内存的操作。尤其是如果你打包后有大量的脚本文件，那么你可能会花费一次内存开销来加载必要的JavaScript模块。）

此时，你可能想知道为什么我们应该按对象数而不是总内存进行排序。直观地讲，我们正在努力减少内存泄漏，所以我们不应该关注内存的总使用量吗？ 有个很重要的原因导致这样没什么用。

当内存泄漏时，是因为（用Joe Armstrong的说法来解释），你想要香蕉，最终你有了香蕉，拿着香蕉的大猩猩以及整个丛林。 如果你基于总字节数进行衡量，那么你所衡量的就是丛林，而不是香蕉（译者注：【内存泄漏】泄漏的大小总是比【已使用内存】小的，如果你关注总共使用多少内存，是没有用的）。

![](https://nolanwlawson.files.wordpress.com/2020/02/gorilla_eating_optimized.jpg?w=570&h=428)

让我们回到上面说的addEventListener的例子。泄漏的来源是事件侦听器，该事件侦听器引用一个函数、或引用一个组件、或可能引用大量的东西，例如数组，字符串和对象。

如果你按总内存对快照差异进行排序，那么它将向您显示数组，字符串和对象，其中大多数可能与泄漏无关。你真正想要找到的是事件侦听器，但是与它所引用的内容相比，它占用的内存很小。要修复泄漏，你想找到香蕉，而不是丛林。

因此，如果按泄漏对象的数量进行排序，你将看到7个事件监听器。也许有7个组件和14个子组件，或者类似的东西。这个“ 7”应该像拇指酸痛一样突出（译者注：奇怪的比喻），因为它是一个不寻常的数字。而且，无论你重复操作多少次，你都应该确切看到泄漏的对象数量。这是你可以快速找到泄漏源的方法。

## Walking the retainer tree

快照差异还将向你显示一个“retainer”链，该链显示哪些对象指向哪些其他对象，从而使内存保持活动状态。这样可以弄清楚泄漏对象的分配位置。

![](https://nolanwlawson.files.wordpress.com/2020/02/screenshot-from-2020-02-16-10-56-12-3.png?w=570&h=111)
图片说明：“retainer”链将向你显示哪个对象正在引用泄漏的对象。读取它的方式是每个对象都由其下面的对象引用。

在上面的示例中，有一个名为someObject的变量，该变量由闭包（也称为“上下文”）引用，并由事件侦听器引用。如果单击源链接，它跳到JavaScript声明，这很简单：

        class SomeObject () { /* ... */ }
        
        const someObject = new SomeObject();
        const onMessage = () => { /* ... */ };
        window.addEventListener('message', onMessage);

在上面的示例中，“上下文”是onMessage闭包，它引用someObject变量。（这是一个人为的示例；实际内存泄漏可能不那么明显！）

但是快照工具有几个限制：

* 如果保存并重新加载快照文件，则将丢失所有与对象分配位置有关的文件引用。例如，你不会看到事件监听器的闭包来自foo.js的第22行。由于这是非常关键的信息，因此保存和发送快照文件几乎没有用。
* 如果涉及到WeakMaps，那么Chrome会向你显示这些引用，即使它们并不重要–清理完其他引用后，这些对象也会被立即分配。因此，它们只是噪音。
* Chrome根据对象的原型对对象进行分类。因此，使用实际的类/函数的次数越多，使用匿名对象的次数就越少，则更容易看到泄漏的确切内容。例如，假设我们的泄漏是否是由于某个对象而不是EventListener引起的。由于对象非常通用，因此我们不太可能看到其中有7个在泄漏。

这是我识别内存泄漏的基本策略。我已经成功地使用了这种策略来发现许多内存泄漏。

但是，本指南只是一个开始–除此之外，你还必须设置断点，记录日志并测试你的修复后的程序，以查看它是否可以解决泄漏。不幸的是，这本质上只是一个耗时的过程。

## 自动化内存泄漏分析

在此之前，我要说的是，我还没有找到一种自动检测内存泄漏的好方法。Chrome具有非标准的performance.memory API，但是出于保护隐私原因，它没有非常精确的粒度，因此你无法在生产环境中真正使用它来识别泄漏。W3C Web性能工作组过去曾讨论过内存工具，但尚未就替代该API的新标准达成共识。

在开发或综合测试环境中，你可以使用Chrome标志--enable-precise-memory-info来增加此API的精确粒度。你也可以通过调用专有的Chromedriver命令：takeHeapSnapshot创建快照文件。但是，这也具有上述相同的限制–你可能想要连续获取三个并丢弃前两个。

由于事件侦听器是最常见的内存泄漏源，因此我使用的另一种技术是对addEventListener和removeEventListener API进行打补丁，以对其引用计数并确保它们返回零。这有个[示例](https://github.com/nolanlawson/pinafore/blob/2edbd4746dfb5a7c894cb8861cf315c800a16393/tests/spyDomListeners.js)。

在Chrome DevTools中，你还可以使用专有的getEventListeners API来查看附加到特定元素的事件侦听器。注意，这只能在DevTools中使用。

更新：Mathias Bynens向我介绍了另一个有用的DevTools API：queryObjects，它可以向你显示使用特定构造函数创建的所有对象。Christoph Guttandin也有一篇有趣的博客文章，内容涉及在Puppeteer中使用此API进行自动内存泄漏检测。

## 总结

在Web应用程序中查找和修复内存泄漏的情况仍然很初级。在这篇博客文章中，我介绍了一些对我有用的技术，但是请记住，这仍然是一个困难且耗时的过程。

与大多数性能问题一样，预防大于治疗。你可能会发现值得进行综合测试，而不是在事实发生后尝试调试内存泄漏。尤其是如果页面上有多个泄漏，则可能会变成洋葱剥皮练习-你修复一个泄漏，然后查找另一个泄漏，然后重复一遍又一遍（整个过程都在哭泣！）（译者注：比喻这个查内存泄漏过程很辛苦，很累）。 如果你知道几个内存泄漏模式，代码审查还可以帮助捕获常见的内存泄漏模式（译者注：预防大于治疗）。

JavaScript是一种内存安全的语言，但讽刺的是，在Web应用程序中泄漏内是很容易的。不过，部分原因只是UI设计所固有的-我们需要侦听鼠标事件，滚动事件，键盘事件等，而这些都是容易导致内存泄漏的模式。但是，通过尝试降低Web应用程序的内存使用量，我们可以提高运行时性能，避免崩溃，并尊重用户设备上的资源限制。